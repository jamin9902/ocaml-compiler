(*
                         CS 51 Final Project
                         MiniML -- Evaluation
                             Spring 2017
*)

(* This module implements a small untyped ML-like language under
   various operational semantics.
 *)

open Expr ;;
open Bignum ;;

(* Exception for evaluator runtime, generated by a runtime error *)
exception EvalError of string ;;
(* Exception for evaluator runtime, generated by an explicit "raise" construct *)
exception EvalException ;;


(* Environments and values *)

module type Env_type = sig
    type env
    type value =
      | Val of expr
      | Closure of (expr * env)
    val create : unit -> env
    val close : expr -> env -> value
    val lookup : env -> varid -> value
    val extend : env -> varid -> value ref -> env
    val env_to_string : env -> string
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : Env_type =
  struct
    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    (* Creates an empty environment *)
    let create () : env = [] ;;

    (* Creates a closure from an expression and the environment it's
       defined in *)
    let close (exp : expr) (env : env) : value =
      Closure (exp, env) ;;

    (* Looks up the value of a variable in the environment *)
    let lookup (env : env) (varname : varid) : value =
      !(List.assoc varname env);;

    (* Returns a new environment just like env except that it maps the
       variable varid to loc *)
    let extend (env : env) (varname : varid) (loc : value ref) : env =
      try
        let _x = lookup env varname in
        List.map (fun (v_name, value) -> if v_name = varname then (v_name, loc)
                                       else (v_name, value)) env
      with
        Not_found -> (varname, loc) :: env;;

    (* Returns a printable string repreesentation of an environment *)


    (* Returns a printable string representation of a value; the flag
       printenvp determines whether to include the environment in the
       string representation when called on a closure *)
    let rec value_to_string ?(printenvp : bool = true) (v : value) : string =
      match v with
      | Val e -> exp_to_string e
      | Closure (exp, env) -> if printenvp then  exp_to_string exp ^
                                " in environment: " ^ env_to_string env
                              else exp_to_string exp

    and env_to_string (env : env) : string =
      match env with
      |[] -> ""
      | (var, valref) :: [] -> var ^ " = " ^ value_to_string !valref
      | (var, valref) :: tl -> var ^ " = " ^ value_to_string !valref ^ ", " ^
                                env_to_string tl;;
  end
;;


(* helper function to evaluate binops
 * result is of type Env.value
 *)
let binopeval (bop : binop)
              (Env.Val e1 : Env.value)
              (Env.Val e2 : Env.value) : Env.value =
  match bop, e1, e2 with
  (* patterns for Plus *)
  | Plus, Num x1, Num x2 -> Env.Val (Num (x1 + x2))
  | Plus, Float x1, Float x2 -> Env.Val (Float (x1 +. x2))
  | Plus, Bignum b1, Bignum b2 -> Env.Val (Bignum (BN.plus b1 b2))
  | Plus, _, _ ->
      raise (EvalError "can't add non-integers or non-floats or non-bignums")
  (* patterns for Minus *)
  | Minus, Num x1, Num x2 -> Env.Val (Num (x1 - x2))
  | Minus, Float x1, Float x2 -> Env.Val (Float (x1 -. x2))
  | Minus, Bignum b1, Bignum b2 -> Env.Val (Bignum (BN.plus b1 (BN.negate b2)))
  | Minus, _, _ ->
      raise (EvalError "can't subtract non-integers")
  (* patterns for Times *)
  | Times, Num x1, Num x2 -> Env.Val (Num (x1 * x2))
  | Times, Float x1, Float x2 -> Env.Val (Float (x1 *. x2))
  | Times, Bignum b1, Bignum b2 -> Env.Val (Bignum (BN.times b1 b2))
  | Times, _, _ ->
      raise (EvalError "can't multiply non-integers, non-floats or non-bignums")
  (* patterns for Equals *)
  | Equals, Num x1, Num x2 -> Env.Val (Bool (x1 = x2))
  | Equals, Bool x1, Bool x2 -> Env.Val (Bool (x1 = x2))
  | Equals, Float x1, Float x2 -> Env.Val (Bool (x1 = x2))
  | Equals, String s1, String s2 -> Env.Val (Bool (s1 = s2))
  | Equals, Bignum b1, Bignum b2 -> Env.Val (Bool (BN.equal b1 b2))
  | Equals, _, _ ->
      raise (EvalError "can't compare (equals)")
  (* patterns for LessThan *)
  | LessThan, Num x1, Num x2 -> Env.Val (Bool (x1 < x2))
  | LessThan, Float x1, Float x2 -> Env.Val (Bool (x1 < x2))
  | LessThan, Bignum b1, Bignum b2 -> Env.Val (Bool (BN.less b1 b2))
  | LessThan, _, _ ->
      raise (EvalError "can't compare non-integers, non_floats or non-bignums")
;;

(* helper function to evaluate binops
 * result is of type Env.value
 *)
let unopeval (uop : unop) (Env.Val e : Env.value) : Env.value =
  match uop, e with
  | Negate, Num x -> Env.Val (Num (~- x))
  | Negate, Float x -> Env.Val (Float (~-. x))
  | Negate, Bignum b -> Env.Val (Bignum (BN.negate b))
  | Negate, _ -> raise (EvalError "cannot negate non-integer")
;;

(* helper function to concatenate strings *)
let concat_eval (Env.Val e1 : Env.value) (Env.Val e2 : Env.value) =
  match e1, e2 with
  | String s1, String s2 -> Env.Val (String(s1 ^ s2))
  | _, _ -> raise (EvalError "cannot concatenate non-strings")
;;

(* helper function to obtain expr from Env.Val *)
let val_to_e (Env.Val value : Env.value) = value ;;
(* The evaluation function: Returns the result of type `value` of
   evaluating the expression `exp` in the environment `env`. *)

let eval_t exp _env = exp ;;

(* substitution model *)
let eval_s (e : expr) (_env : Env.env) : Env.value =
  let rec eval_s (e : expr) : Env.value =
    match e with
    | Var v -> raise (EvalError ("Unbound Variable " ^ v))
    | Num _ | Float _ | Bool _ | Fun _ | String _ | Bignum _ | Unassigned  -> Env.Val e
    | Unop (uop, e) -> unopeval uop (eval_s e)
    | Binop (bop, e1, e2) -> binopeval bop (eval_s e1) (eval_s e2)
    | Concat (e1, e2) -> concat_eval (eval_s e1) (eval_s e2)
    | Conditional (e1, e2, e3) ->
        if (eval_s e1 = Env.Val (Bool true)) then eval_s e2
        else eval_s e3
    | Let (x, def, body) -> eval_s (subst x (val_to_e (eval_s def)) body)
    | Letrec (x, def, body) ->
        eval_s (subst x (subst x (Letrec (x, def, Var x)) def)body)
    | Raise -> raise EvalException
    | App (e1, e2) ->
        match eval_s e1 with
        | Env.Val Fun (x, body) -> eval_s (subst x (val_to_e (eval_s e2)) body)
        | _ -> raise (EvalError "can't apply expression to non-function")
  in eval_s e
;;

type model = | Dynamic | Lexical ;;

let create_eval (model: model) (exp : expr) (env : Env.env) : Env.value =
  let rec create_eval (exp : expr) (env : Env.env) : Env.value =
    match exp with
    | Var v -> (try
                  match Env.lookup env v with
                  | Env.Val e -> Env.Val e
                  | Env.Closure (e, env2) -> create_eval e env2
                with
                  Not_found -> raise (EvalError ("Unbound Variable " ^ v)))
    | Num _ | Float _ | Bool _  | String _ | Bignum _ | Unassigned  -> Env.Val exp
    | Fun _ -> if model = Dynamic then Env.close exp (Env.create ())
               else Env.close exp env
    | Unop (uop, e) -> unopeval uop (create_eval e env)
    | Binop (bop, e1, e2) -> binopeval bop (create_eval e1 env) (create_eval e2 env)
    | Concat (e1, e2) -> concat_eval (create_eval e1 env) (create_eval e2 env)
    | Conditional (e1, e2, e3) ->
        if (create_eval e1 env = Env.Val (Bool true)) then create_eval e2 env
        else create_eval e3 env
    | Let (x, def, body) -> let value = ref (create_eval def env) in
                            create_eval body (Env.extend env x value)
    | Letrec (x, def, body) -> let value = ref (Env.Val Unassigned) in
                               let new_env = Env.extend env x value in
                               let new_value = create_eval def new_env in
                               (match new_value with
                               | Env.Val Var _  -> raise (EvalError ("Variable reached" ))
                               | _ -> value := new_value;
                                      create_eval body new_env )
    | Raise -> raise EvalException
    | App (e1, e2) ->
        let arg = ref (create_eval e2 env) in
        match create_eval e1 env with
        | Env.Closure (Fun (x, body), old_env) ->
          if model = Dynamic then create_eval body (Env.extend env x arg)
          else create_eval body (Env.extend old_env x arg)
        | _ -> raise (EvalError "can't apply expression to non-function")
  in
  create_eval exp env
  ;;

(* dynamic environment model *)
let eval_d = create_eval Dynamic;;

(* lexical environment model  *)
let eval_l = create_eval Lexical;;

(** The external evaluator, which can be either the identity function,
    the substitution model version or the dynamic or lexical
    environment model version. *)

(* let evaluate = eval_t;; *)
 (*  let evaluate a b = val_to_e (eval_s a b);; *)
let evaluate a b = val_to_e (eval_s a b);;
(* let evaluate a b = val_to_e (eval_d a b);; *)
